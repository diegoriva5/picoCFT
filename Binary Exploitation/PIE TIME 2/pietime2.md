# PIE TIME 2

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
}
```

This challenge seems like the PIE TIME one. Looking at the code, we can find a format string vulnerability:
```c
char buffer[64];
printf("Enter your name:");
fgets(buffer, 64, stdin);
printf(buffer);     //here is the vulnerability!!!
```

So, to analyze it we can use `gdb`. This can be installed by using `sudo apt install gdb`: if not updated, run `sudo apt-get update`.<br>
Now set up permissions for `./vuln`: `chmod +x vuln`.<br>
Now, run `gdb`: `gdb ./vuln`.

To see the main address, we run the `disas main`. This command gives us the address `0x0000555555555400`. Then, we disassemble the `win()` function to get its address: `0x000055555555536a`. The distance from the two address is `0x96`. Even after some runs of the program, the distance remains the same. Due to PIE, the address of main will be different for each run of the program, so we need to leak the main address during the execution of the program, and in our case the format string vulnerability could come in help.<br>
We run the program again, and try to leak some memory addresses by using `%p` and overflow the buffer. We find that the 19th value is very close to the `main` address: `0x555555555441`. <br>

Now we run the program and enter the `%19$p` to get the address. Now, we know that the address given is `41` away from the `main` address. `0x555555555441 - 0x41 = 0x0000555555555400`. Then, we are `0x96` away from the `win` address. So, insert the address `0x0000555555555400 - 0x96` to get the flag.










